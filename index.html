<html>

<head>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <title>ChordPicker</title>
    <script>
    </script>
    <script src="dist/bundle.js"></script>
    <script src="midi.js"></script>
    <style>
      #melodys {
        display: flex;
      }
      #melodys > div {
        display: flex;
        flex-direction: column;
        margin: 1px;
        width: 2rem;
      }
      #chords {
        display: flex;
      }
      .chord {
        display: flex;
        flex-direction: column;
        margin: 1px;
        width: 2rem;
      }
      .d-flex {
        display: flex;
      }
      .editing-chord {
        display: flex;
        flex-direction: column;
        padding: 1rem;
        border: 1px solid black;
        height: 30rem;
        width: 100%;
      }
      .chord-filters {
        display: flex;
        flex-direction: column;
      }
      .chord-filters > div {
        display: flex;
        justify-content: space-between;
      }
    </style>
</head>

<body>
    <div id="vue-template" class="d-flex" style="flex-direction: column;">
      <input type="text" v-model="melodyText"></input>
      <div id="melodys">
        <div v-for="note in melody">
          <p>{{ note.note }}<span v-if="note.sharp == -1">b</span><span v-if="note.sharp == 1">#</span></p>
          <input type="number" min="-1" max="1" v-model="note.sharp"></input>
          <select v-model="note.duration">
            <option value="w">Whole</option>
            <option value="h">Half</option>
            <option value="q">Quarter</option>
            <option value="e">Eighth</option>
            <option value="s">Sixteenth</option>
          </select>
          <input type="checkbox" v-model="note.dotted"></input>
        </div>
      </div>
      <div id="score">

      </div>
      <div id="chords">
        <div v-for="chordSlot in chordSlots" class="d-flex">
          <div v-if="chords[chordSlot]" class="d-flex">
            <div v-if="editingChord == chordSlot" class="editing-chord">
              <div class="chord-filters">
                <div>
                  <label for="chord-key-filter">Key</label>
                  <select v-model="selectedChordKey" id="chord-key-filter">
                    <option v-for="rootPitchName in chordRootChoices" :value="rootPitchName">{{ rootPitchName }}</option>
                  </select>
                </div>
                <div>
                  <label for="chord-root-filter">Root</label>
                  <select v-model="selectedChordRoot" id="chord-root-filter">
                    <option :value="null">Any</option>
                    <option v-for="rootPitchName in chordRootChoices" :value="rootPitchName">{{ rootPitchName }}</option>
                  </select>
                </div>
                <div>
                  <label for="chord-roman-filter">Roman</label>
                  <select v-model="selectedChordRoman" id="chord-roman-filter">
                    <option :value="null">Any</option>
                    <option v-for="romanNumeral in romalNumeralChoices" :value="romanNumeral">{{ romanNumeral }}</option>
                  </select>
                </div>
                <div>
                  <label for="chord-type-filter">Type</label>
                  <select v-model="selectedChordType" id="chord-type-filter">
                    <option :value="null">Any</option>
                    <option v-for="chordType in chordTypes" :value="chordType">
                      {{ chordType }}
                    </option>
                  </select>
                </div>
              </div>
              <select v-model="selectedChord">
                <option v-for="chord in filteredChordChoicesByTotalScore" :value="chord">
                  {{ chord.chord.toString() }} {{ chord.inversion }} {{ chord.doubling }} : {{ chord.totalScore }}
                </option>
              </select>
              <div v-if="selectedChord">
                <div v-for="problem in ((selectedChord.selfProblem || {}).problems || {})">
                  <div v-for="problemValue in problem">
                    <p>{{ problemValue.comment }}: {{ problemValue.value }}</p>
                  </div>
                </div>
                <div v-for="problem in ((selectedChord.prevProblem || {}).problems || {})">
                  <div v-for="problemValue in problem">
                    <p>{{ problemValue.comment }}: {{ problemValue.value }}</p>
                  </div>
                </div>
                <div v-for="problem in ((selectedChord.nextProblem || {}).problems || {})">
                  <div v-for="problemValue in problem">
                    <p>{{ problemValue.comment }}: {{ problemValue.value }}</p>
                  </div>
                </div>
              </div>
              <button @click="deleteChord()">DELETE</button>
              <button @click="saveChord()">OK</button>
            </div>
            <div v-else class="chord">
              <p>{{ chords[chordSlot].name }}</p>
              <p>{{ chords[chordSlot].numeral }}</p>
              <p>{{ chords[chordSlot].inversion }}</p>
              <button @click="startEditingChord(chordSlot)">E</button>
            </div>
          </div>
          <div v-else>
            <button @click="addChordToIndex(chordSlot)">+</button>
          </div>
        </div>
      </div>
      <div>
        <button id="btn-play">PLAY</button>
        <button id="btn-pause">PAUSE</button>
        <button id="btn-stop">STOP</button>
        <button id="btn-save" @click="saveSong()">SAVE</button>
      </div>
    </div>
</body>
<script>

</script>
<script>
const { createApp } = Vue

createApp({
  data() {
    return {
      melodyText: "",
      melody: [],
      params: {},
      chords: {},
      editingChord: -1,
      chordChoices: [],
      selectedChordKey: 'C',
      selectedChordRoot: null,
      selectedChordRoman: null,
      selectedChordType: null,
      selectedChord: null,
    }
  },
  mounted() {
    this.params = new window.MainMusicParams();

    this.chords = JSON.parse(window.localStorage.getItem('chords') || "{}") || {};
    for (let key in this.chords) {
      this.chords[key].chord = window.Chord.fromObject(this.chords[key].chord);
      this.chords[key].notes = (this.chords[key].notes || []).map(note => window.Note.fromObject(note));
    }
    console.log(this.chords);
    this.melody = JSON.parse(window.localStorage.getItem('melody') || "[]") || [];
    this.melodyText = window.localStorage.getItem('melodyText') || "";
  },
  computed: {
    noteNames() {
      return ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    },
    maxDivision() {
      return this.melody.length * 12 + 24 * 12;
    },
    chordSlots() {
      ret = [];
      for (let i = 0; i < this.maxDivision; i += 12) {
        ret.push(i);
      }
      return ret;
    },
    chordToEdit() {
      return this.chords[this.editingChord];
    },
    chordRootChoices() {
      let ret = new Set();
      for (let i = 0; i < this.chordChoices.length; i++) {
        const chord = this.chordChoices[i];
        const rootName = chord.chord.notes[0].pitchName();
        ret.add(rootName);
      }
      return Array.from(ret).sort();
    },
    romalNumeralChoices() {
      const ret = new Set();
      for (let i = 0; i < this.chordChoices.length; i++) {
        const chord = this.chordChoices[i];
        ret.add(chord.chord.getChordDegree(this.selectedChordKeyPitch));
      }
      return Array.from(ret).sort();
    },
    chordTypes() {
      return window.chordTypes;
    },
    chordInversionsAndDoublings() {
      const ret = {};
      for (let i = 0; i < this.chordChoices.length; i++) {
        const chord = this.chordChoices[i];
        const rootName = chord.chord.notes[0].pitchName();
        if (!ret[rootName]) {
          ret[rootName] = [];
        }
        ret[rootName].push(chord);
        ret[rootName].sort((a, b) => {
          return a.totalScore - b.totalScore;
        });
      }

      return ret;
    },
    filteredChordChoices() {
      let ret = this.chordChoices;
      if (this.selectedChordRoot) {
        ret = ret.filter((chord) => {
          return chord.chord.notes[0].pitchName() == this.selectedChordRoot;
        });
      }
      if (this.selectedChordRoman) {
        ret = ret.filter((chord) => {
          return chord.chord.getChordDegree(this.selectedChordKeyPitch) == this.selectedChordRoman;
        });
      }
      if (this.selectedChordType) {
        ret = ret.filter((chord) => {
          return chord.chord.chordType == this.selectedChordType;
        });
      }
      return ret;
    },
    filteredChordChoicesByTotalScore() {
      return this.filteredChordChoices.sort((a, b) => {
        return a.totalScore - b.totalScore;
      });
    },
    chordChoicesWithSingleDoublingByTotalScore() {
      // Only show one (best) doubling per chordchoice
      return this.chordChoices.sort((a, b) => {
        return a.totalScore - b.totalScore;
      });
    },
    selectedChordKeyPitch() {
      return (new window.Note(this.selectedChordKey)).pitch;
    }
  },
  methods: {
    saveSong() {
      window.localStorage.setItem('chords', JSON.stringify(this.chords));
      window.localStorage.setItem('melody', JSON.stringify(this.melody));
      window.localStorage.setItem('melodyText', this.melodyText);
    },
    initMelodyNote(noteName) {
      return {
        'note': noteName,  // Can be a space or CDEFGAH
        'sharp': 0,
        'duration': 'q',
        'dotted': false,
      }
    },
    initChord(index) {
      return {
        'name': '',
        'numeral': '',
        'inversion': '',
        'doubling': '',
        'division': index,
      }
    },
    refreshXML() {
      window.loadMelody(this.melody, this.chords, this.params)
    },
    addChordToIndex(index) {
      this.chords[index] = this.initChord(index);
      this.startEditingChord(index);
    },
    async startEditingChord(index) {
      let tmpIndex = index - 1;
      let prevChord = this.chords[tmpIndex];
      while (!prevChord && tmpIndex >= 0) {
        prevChord = this.chords[tmpIndex];
        tmpIndex--;
      }
      tmpIndex = index + 1;
      let nextChord = this.chords[tmpIndex];
      while (!nextChord && tmpIndex <= this.chordSlots[this.chordSlots.length - 1]) {
        nextChord = this.chords[tmpIndex];
        tmpIndex++;
      }
      this.editingChord = index;
      this.chordChoices = await window.getChordChoices(this.melody, index, prevChord, nextChord, this.params);
      if (this.chords[index]) {
        this.selectedChord = this.chords[index];
      }
      this.selectedChordKey = "C";
      this.selectedChordRoot = null;
      this.selectedChordRoman = null;
      this.selectedChordType = null;
    },
    saveChord() {
      this.chords[this.editingChord] = this.selectedChord;
      this.chords[this.editingChord].division = this.editingChord;
      this.editingChord = -1;
      this.refreshXML();
    },
    deleteChord() {
      delete this.chords[this.editingChord];
      this.editingChord = -1;
      this.refreshXML();
    },
  },
  watch: {
    chordChoices() {
      if (!this.selectedChord) {
        this.selectedChord = this.chordChoices[0];
      }
    },
    selectedChordRoot() {
      if (this.selectedChordRoot) {
        this.selectedChord = this.chordInversionsAndDoublings[this.selectedChordRoot][0];
      }
    },
    melodyText(newValue) {
      const newNotes = newValue.split("")
      if (this.melody.length < newNotes.length) {
        // Maybe new note is inserted in between
        for (let i = 0; i < newNotes.length; i++) {
          if (!this.melody[i] || this.melody[i].note != newNotes[i]) {
            this.melody.splice(i, 0, this.initMelodyNote(newNotes[i]))
          }
        }
      }
      else if (this.melody.length > newNotes.length) {
        // Maybe a note is deleted from the middle
        for (let i = 0; i < newNotes.length; i++) {
          if (this.melody[i].note != newNotes[i]) {
            this.melody.splice(i, 1)
          }
        }
      }
      // Check that noteName matches for each note
      for (let i = 0; i < newNotes.length; i++) {
        if (this.melody[i].note != newNotes[i]) {
          this.melody[i].note = newNotes[i]
          this.melody[i].sharp = 0
        }
      }
    },
    melody: {
      handler() {
        this.refreshXML();
      },
      deep: true,
    }
  }

}).mount('#vue-template')
</script>
</html>